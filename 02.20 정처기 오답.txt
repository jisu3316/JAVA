22-02-20 오답노트 21년 5월문제
6. GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?
① factory method pattern은 상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위클래스에서 인스턴스를 생성하도록 하는 방식이다.
② prototype pattem은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
③ bridge pattem은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
④ mediator pattem은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.

GOF(Gangs of Four)의 디자인패턴 종류의 대해 이해 필요함.
(1)생성 패턴(Creational Pattern)
-객체를 생성하는데 관련된 패턴들
-객체가 생성되는 과정의 유연성을 높이고 코드의 유지를 쉽게 함

(2)구조 패턴(Structural Pattern)
-프로그램 구조에 관련된 패턴들
-프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들

(3)행위 패턴(Behavioral Pattern)
-반복적으로 사용되는 객체들의 상호작용을 패턴화 해놓은 것들

10.CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?
① 구조적 기법
② 프로토타이핑 기술
③ 정보 저장소 기술
④ 일괄처리 기술--CASE는 여러 작업들을 자동화하는 도구인데 일괄처리기술은 정반대의미이다. 

CASE 
소프트웨어 공학의 여러 작업들을 자동화하는 도구
소프트웨어 부품의 재사용성을 향상시켜준다.
소프트웨어 품질과 일관성을 효율적으로 관리할 수 있다.
소프트웨어 생명 주기의 모든 단계를 연결시켜 주고 자동화시켜 준다.
소프트웨어의 유지보수를 용이하게 수행할 수 있도록 해준다.
소프트웨어 공학의 여러 작업들을 자동화하는 도구이다.
소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능을 제공한다.
자료흐름, 비즈니스 프로세스 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어도 CASE 도구이다.

14. UML 다이어그램이 아닌 것은?
① 액티비티 다이어그램(Activity diagram)
② 절차 다이어그램(Procedural diagram)
③ 클래스 다이어그램(Class diagram)
④ 시퀀스 다이어그램(Sequence diagram)

Unified Modeling Language(영어로도 다 알아야 함.)
통합 모델링 언어
시스템을 모델로 표현해주는 대표적인 모델링 언어

1.구조 다이어그램(Structure Diagram)
	-클래스 다이어그램(Class Diagram)
	-객체 다이어그램(Object Diagram)
	-복합체 구조 다이어그램(Complex Structure Diagram)
	-배치 다이어그램(Deployment Diagram)
	-컴포넌트 다이어그램(Component Diagram)
	-패키지 다이어그램(Package Diagram)
2.행위 다이어그램(Behavior Diagram)
	-활동 다이어그램(Activity Diagram)
	-상태 머신 다이어그램(State Machine Diagram)
	-유스케이스 다이어그램(Use Case Diagram)
	-상호작용 다이어그램(Interaction Diagram)
	-커뮤니케이션 다이어그램(Communication Diagram)
	-시퀀스 다이어그램(Sequence Diagram)


17. 요구사항 관리 도구의 필요성으로 틀린 것은?
① 요구사항 변경으로 인한 비용 편익 분석
② 기존 시스템과 신규 시스템의 성능 비교--요구사항과 다른 성능얘기이다.
③ 요구사항 변경의 추적
④ 요구사항 변경에 따른 영향 평가

18. 애자일 개발 방법론이 아닌 것은?
① 스크럼(Scrum)
② 익스트림 프로그래밍(XP, eXtreme Programming)
③ 기능 주도 개발(FDD, Feature Driven Development)
④ 하둡(Hadoop)

Agile
절차나 문서보다 사람과 업무 자체를 중요시하여 유연하고 신속한 개발을 추구하는 방법론
애자일 그 자체로는 방법론이라기 보단 철학에 가깝다.
애자일 정신을 기반으로 구체화된 실천기법들이 '애자일 방법론' 또는 '애자일 기법', '애자일 프로세스'라고 불린다.
XP : 테스트 강조 ,최근가장 주목
SCRUM : 프로젝트르 ㄹ30일단위 스프린트로 분리 팀은 매일 스크럼미팅 15분으로 계획수림 스프린트와 트래킹 중점
DSDM : 기능모델 ,설계와 구현 ,수행 3단계사이클(2~6)주 반복 ,주로영국에서 사용
FDD : 짧은 ITERATION(2주) 설계와 구축을 반복
Crystal : 프로젝트 규모 및 유형에 따른 맞춤형 방범론 인적자원중심

20. 사용자 인터페이스(UI)의 특징으로 틀린 것은?
① 구현하고자 하는 결과의 오류를 최소화한다.
② 사용자의 편의성을 높임으로써 작업시간을 증가시킨다.
③ 막연한 작업 기능에 대해 구체적인 방법을 제시하여 준다.
④ 사용자 중심의 상호 작용이 되도록 한다.

UI; User Interface
사용자와 시스템 간의 상호작용을 원활하게 도와주는 장치나 소프트웨어
직관성: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
유효성: 사용자의 목적을 정확하게 달성하여야 한다.
학습성: 누구나 쉽게 배우고 익힐 수 있어야 한다.
유연성: 사용자의 요구사항을 최대한 수용하며, 오류를 최소화하여야 한다

21. 힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?
① 정렬할 입력 레코드들로 힘을 구성하고가장 큰 키 값을 갖는 루트 노드를제거하는 과정을 반복하여 정렬하는기법이다.
② 평균 수행 시간은 O(nlog2n)이다.
③ 완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.
④ 최악의 수행 시간은 O(2n4)이다.-- 최악, 평균, 최적 수행시간이 모두 O(nlogn)임

Heap Sort
정렬한 입력 레코드들로 힙을 구성하고 가장 큰 키값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법
완전 이진트리의 일종으로 우선순위 que를 위하여 만들어진 자료 구조
최댓값, 최솟값을 쉽게 추출할 수 있음
시간복잡도는 nlog(2)n으로 일정함(O(nlog2n))

22. 다음 중 단위 테스트를 통해 발견할 수 있는 오류가 아닌 것은?
① 알고리즘 오류에 따른 원치 않는 결과
② 탈출구가 없는 반복문의 사용
③ 모듈 간의 비정상적 상호작용으로 인한 원치 않는 결과
④ 틀린 계산 수식에 의한 잘못된 결과

단위 테스트는 테스트 코드가 독립적이어야 함으로 각 모듈간의 상호작용은 해당되지 않는다
3️내용은 통합 테스트(Integration Test)에서 발견할 수 있는 오류이다
Unit Test
함수, 모듈, 기능 등 세부 단위별로 수행하는 소프트웨어 테스트
컴포넌트 테스트(Component Test)라고도 부른다.

일반적인 화이트박스 기능 테스트의 종류

제어흐름 테스트
조건/결정 테스트
인터페이스 테스트
자료구조 테스트
실행경로 테스트
예외처리 테스트

28. 디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?
① Dataware house-- 클리어링 하우스
② DRM Controller
③ Packager
④ Contents Distributor
30. 블랙박스 테스트를 이용하여 발견할 수 있는 오류가 아닌 것은? 3

1비정상적인 자료를 입력해도 오류 처리를 수행하지 않는 경우

2정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우

3️반복 조건을 만족하는데도 루프 내의 문장이 수행되지 않는 경우--화이트박스

4️경계값을 입력할 경우 요구된 출력 결과가 나오지 않는 경

[ 블랙박스 테스트 ]
✅경계값 분석 : 경계값에서 오류가 발생될 확률이 높다는 점을 이용
✅기능 테스트
✅프로그램 구조 고려 X

32. 정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은? 1

1️합병정렬

2️버블정렬

3️선택정렬

4️삽입정렬

✅O(N*log₂N) : 선형 로그형 복잡도 : 로그,변수에 비례 ⇒ 퀵정렬, 병합정렬
✅O(N₂) : 제곱형 : 제곱에 비례 ⇒ 버블정렬, 삽입정렬, 선택정렬
✅정렬된 데이터의 경우, 버블정렬과 삽입정렬은 O(N) 이 될 수 있음

34. EAI(Enterprise Application Integration) 구축 유형에서 애플리케이션 사이에 미들웨어를 두어 처리하는 것은? (문제 오류로 가답안 발표시 1번으로 발표되었지만 확정 답안 발표시 1, 3, 4번이 정답처리 되었습니다. 여기서는 가답안인 1번을 누르면 정답 처리 됩니다.)
① Message Bus
② Point-to-point--직접 1대1연결하는 방식
③ Hub &Spoke
④ Hybrid


[ EAI (Enterprise Application Integration) : 기업 내 상호 연동이 가능하게 해주는 솔루션 ]
◼비즈니스 간 통합 및 연계성을 증대시켜 각 시스템 간의 확정성을 높여줌

[ EAI (Enterprise Application Integration) 구축유형 ]
✅Point-to-Point : 가장 기본적인 애플리케이션 통합 방식으로
                        ,애플리케이션을 1:1 로 연결 변경 및 재사용이 어려움

✅Hub & Spoke : 단일 접점인 허브를 통해 데이터를 전송하는 중앙 집중형 방식
                        ,확장 및 유지 보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향

✅Message Bus (ESB 방식) : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
                                     ,확장성이 뛰어나며 대용량 처리가 가능

✅Hybrid : 그룹 내에서는 Hub & Spoke 방식
               ,그룹 간에는 Message 방식 사용 데이터 병목 현상 최소화

35. 인터페이스 구현 검증 도구가 아닌 것은?
① Foxbase
② STAF
③ watir
④ xUnit
Fox-base 프로그래밍언어
인터페이스 구현 검증 도구 : xUnit, STAF, FitNesse, NTAF, Selenium, watir

36. 클린코드 작성원칙에 대한 설명으로 틀린 것은? 
① 코드의 중복을 최소화 한다.
② 코드가 다른 모듈에 미치는 영향을 최대화하도록 작성한다.
③ 누구든지 코드를 쉽게 읽을 수 있도록 작성한다.
④ 간단하게 코드를 작성한다.
 
(문제 잘읽으면 답이 나온다 2번이 최소화하는거라고 읽었다... 실전에서는 이런 실수를 하면안되겠다. 3번을 골랐는데 누구든디 코드를 쉽게읽으면 보안성이슈가생길거라생각함.(쓸데없는생각..))
[ 클린코드 작성원칙 ]
✅중복성 최소화 : 중복된 코드는 삭제, 공통된 코드 사용
✅가독성 : 누구나 코드를 쉽게 읽을 수 있도록 작성
✅단순성 : 한번에 한 가지를 처리하도록 코드를 간단하게 작성
✅의존성 배제 : 코드가 다른 모듈에 미치는 영향을 최소화 할것
                     ,코드 변경시 다른 부분에 영향이 없도록 작성

40. 다음 중 스택을 이용한 연산과 거리가 먼 것은? 1

1️선택정렬

2️재귀호출

3️후위표현(Post-fix expression)의 연산

4️깊이우선탐색

✅선택정렬은 큐를 이용해서 정렬
데이터베이스 구축
42. 시스템 카탈로그에 대한 설명으로 옳지 않은 것은? 1

1️사용자가 직접 시스템 카탈로그의 내용을 갱신하여 데이터베이스 무결성을 유지한다

2️시스템 자신이 필요로 하는 스키마 및 여러가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다

3️시스템 카탈로그에 저장되는 내용을 메타데이터라고도 한다

4️시스템 카탈로그는 DBMS가 스스로 생성하고 유지한다

✅시스템 카탈로그는 DBMS가 스스로 생성하고 유지하기 때문에
    INSERT, DELETE, UPDATE문으로 시스템 카탈로그를 갱신하는 것은 허용되지 않습니다

46. 테이블 R1, R2에 대하여 다음 SQL문의결과는? 2


문제
R1 테이블
학번 		학점
20201111		15
20202222		20

R2 테이블
학번		과목번호
20202222		CS200
20203333		CS300

(select 학번 from r1) intersect (select 학번 from r2) 
이런 기본적인 문제는 실전에서 틀리면 안될것같다 ..하..

4번
✅INTERSECT : 교집합

47. 데이터베이스 설계 시 물리적 설계 단계에서 수행하는 사항이 아닌 것은? 4

1️레코드 집중의 분석 및 설계

2️접근 경로 설계

3️저장 레코드의 양식 설계

4️목표 DBMS에 맞는 스키마 설계

✅개념적 설계 : 사용자의 요구사항 분석 후, 데이터베이스에 대한 추상적인 형태를 설계
                      개념적 모델을 이용한 개념적 스키마 생성
                      (데이터베이스에 대한 추상적인 설계도, 개체 관계 다이어그램)

✅논리적 설계: 논리적 모델을 이용하여 논리적 스키마 생성
                     ,ERD를 이용하여 데이터베이스 스키마를
                     설계, 테이블 구조도, 개념적 설계 단계에서 생성된
                     ERD를 바탕으로 생성되는 테이블들의 집합

✅물리적 설계 : 특정 DBMS가 제공하는 물리적 구조에 따라 테이블 저장 구조 설계
                      ,필드의 데이터 타입, 인덱스, 테이블 저장 방법 등을 정의

49. 병행제어 기법의 종류가 아닌 것은? 2

1️로킹 기법

2️시분할 기법

3️타임 스탬프 기법

4️다중 버전 기법

✅병행제어 : 동시에 여러 개의 트랜잭션을 병행수행할때, DB의 일관성을 파괴하지 않도록 제어하는 것
✅시분할 기법 : 사용자가 여러개의 작업이 동시에 수행하는 것처럼 느끼도록 분할하는 운영체제 운영기법

51. 다음 관계 대수 중 순수 관계 연산자가 아닌 것은?

1️차집합(difference)

2️프로젝트(project)

3️조인(join)

4️디비전(division)

[ 순수 관계 연산자 ]
✅select δ ⇒수평단절, 행을 다가져옴
✅project π ⇒수직단절, 열을 다가져옴
✅join ▷◁ : 공통 속성을 이용해 두개의 릴레이션 튜플을연결→만들어진 튜플로 반환
✅division ÷ : 릴S의 모든 튜플과 관련있는 릴R의 튜플반환

[ 일반 집합 연산자 ]
✅UNION : 합집합
✅INTERSECTION : 교집합
✅DIFFERENCE : 차집합
✅CARTESIAN PRODUCT : 교차곱.

53. 릴레이션 R의 차수가 4이고 카디널리티가 5이며

    ,릴레이션 S의 차수가 6이고 카디널리티가 7일 때

    ,두 개의 릴레이션을 카티션 프로덕트한 결과의 새로운 릴레이 션의 차수와 카디널리티는 얼마인가? 3

1️24, 35

2️24, 12

3️10, 35

4️10, 12

[ 두 개의 릴레이션을 카티션 프로덕트 ]
차수는 +를 해주고 카디널리티는 *를 해주면 해당 결과가 나옵니다
차수 = 4+6=10
카디널리티 = 5*7=35


56. 관계 데이터베이스 모델에서 차수(Degree)의 의미는? 4

1️튜플의 수

2️테이블의 수

3️데이터베이스의 수

4️애트리뷰트의 수

✅차수 = Degree = Attribute의 수 = 속성의 수(관계 DB의 열) 컬럼수
✅기수 = Cardinality = Tuple의 수 = 대응수(관계 DB의 행) 그 컬럼안에있는 값들의수

60. 제3정규형 (3NF)에서 BCNF(Boyce-Codd Normal Form)가 되기 위한 조건은? 1

1️결정자가 후보키가 아닌 함수 종속 제거

2️이행적 함수 종속 제거

3️부분적 함수 종속 제거

4️원자값이 아닌 도메인 분해

[ 데이터베이스 정규화 ]
비정규형 →
[도메인 분해 →] 제1정규형
[부분 함수 종속 제거 →] 제2정규형
[이행 함수 종속 제거 →] 제3정규형
[결정자가 후보키가 아닌 함수 종속 제거 →] 보이스 코드 정규형(BCNF)
[다중치 종속 제거 →] 제4정규형
[조인 종속제거 →] 제5정규형

앞글자만 따서 '도부이결다조'로 암기

프로그래밍언어 
61. 다음 설명에 해당하는 방식은? 3

◼무선랜에서 데이터 전송시, 매체가 비어 있음을 확인한 뒤

  충돌을 회피하기 위해 임의시간을 기다린 후 데이터를 전송하는 방법

◼네트워크에 데이터의 전송이 없는 경우라도

   동시전송에 의한 충돌에 대비하여 확인신호를 전송

1️STA

2️Collision Domain

3️CSMA/CA

4️CSMA/CD

✅Collision Domain : 충돌 발생을 검출할 수 있는 브리지 간 혹은 다른 계층 장치 간의 이더넷 세그먼트 범위
✅CSMA/CD : 이더넷에서 각 단말이 정송 공유 매체에 규칙있게 접근하기 위한 매체 엑세스 제어 방식

62. 다음 중 가장 약한 결합도(Coupling)는? 4

1️Common Coupling

2️Content Coupling

3️External Coupling

4️Stamp Coupling

[ 결합도 세기 ]
내용(content) > 공통(common) > 외부(external) > 제어(control) > 스탬프 (stamp) > 자료 (data) (암기 해야겠다)

63. 다음 C언어 프로그램이 실행되었을 때의 결과는?

#include <stdio.h>

int main(int argc, char *argv[]){
  int a = 4;
  int b = 7;
  int c = a | b;
  
  printf("%d", c);
  return 0;
}
1️3

2️4

3️7

4️10

a = 4 = 00000100
b = 7 = 00000111
or 연산자는 둘 중 하나만 1이어도 1로 나타내므로, 00000111 = 7

and 연산자일 경우 and 00000100 = 4가 됩니다

65. 교착상태의 해결 방법 중 은행원 알고리즘(Banker's Algorithm)이 해당되는 기법은? 2

1️Detection

2️Avoidance

3️Recovery

4️Prevention

✅Detection(탐지) : 교착상태 발생을 허용하고 발생 시 원인을 규명하여 해결 (ex 자원할당 그래프)
✅Avoidance (회피) : 교착상태 가능성을 배제하지 않고 적절하게 피해나가는 방법 (ex 은행원 알고리즘)
✅Recovery (복구) : 교착상태 발견 후 현황대기를 배제시키거나
                           자원을 중단하는 메모리 할당 기법 (ex 선점, 프로세스 중지(희생자 선택)
✅Prevention(예방) : 교착상태의 필요조건을 부정함으로써
                            교착상태가 발생하지 않도록 미리 예방하는 방법
                            (ex 환형대기, 비선점, 점유와 대기, 상호배제 4가


66. CIDR(Classless Inter-Domain Routing) 표기로 203.241.132.82/27과 같이 사용되었다면

    ,해당 주소의 서브넷 마스크(subnet mask)는? 2

1️255.255.255.0

2️255.255.255.224

3️255.255.255.240

4️255.255.255.248

Ipv4는 32bit로 이루어져 있습니다
ip주소/서브넷마스크로 표기합니다
서브넷마스크숫자대로 앞에서부터 1을채워서 8개씩 끊어 계산하시면됩니다(2진수)
11111111.11111111.11111111.11100000 = 1의 개수가 27개
     255   .    255    .     255   .    224

71. 리눅스 Bash 쉘(Shell)에서 export와 관련한 설명으로 틀린 것은? 1

1️변수를 출력하고자 할 때는 export를 사용해야 한다

2️export가 매개변수 없이 쓰일 경우 현재 설정된 환경변수들이 출력된다

3️사용자가 생성하는 변수는 export 명령어 표시하지 않는 한 현재 쉘에 국한된다

4️변수를 export 시키면 전역(Global)변수처럼 되어 끝까지 기억된다

리눅스에서 변수 출력 : echo $변수명

73. 다음 C언어 프로그램이 실행되었을 때의 결과는? 3

#include <stdio.h>
int main(int argc, char *argv[]){
  int a[2][2] = {{11, 22), (44, 55}};
  int i, sum = 0;
  int *p;
  p= a[0];
  for(i=1; i<4; i++)
  sum += *(p+i);
  printf("%d", sum);
  return 0;
}
155

2️77

3️121

4️132

2차원 배열의 시작순서는 11> 22> 44> 55
도식화 하면
11 / 22
44 / 55
*는 포인터를 의미. 포인터는 주소값.
*p 포인터 p변수에 a배열의 [0]주소값을 넣어줌.
그러나 (p+i)에서 p는 a배열의 [0] 주소값을 가지고 있으나 i = 1로 설정했기때문에
a[1]주소값을 뜻한다. 즉, *p는 첫 for문에서 a[1]주소값을 뜻한다.
22+44+55 = 121이다


74. 페이징 기법에서 페이지 크기가 작아질수록 발생하는 현상이 아닌 것은? 4

1️기억장소 이용 효율이 증가한다

2️입·출력 시간이 늘어난다

3️내부 단편화가 감소한다

4️페이지 맵 테이블의 크기가 감소한다

[ 페이징 기법 : 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법 ]
✅페이징기법을 통해 물리적 메모리는 연속적으로 할당되어 존재할 필요가 없음
✅페이징기법을 통해 비연속적 메모리를 연속적 메모리처럼 만들 수 있음

[ 페이지 크기가 작은 경우 ]
✅더 많은 페이징 사상테이블 필요
✅내부 단편화 감소
✅페이지의 집합을 효율적으로 운영가능
✅기억장치의 효율이 좋음
✅총 입출력 시간 증가

[ 페이지 크기가 클 경우 ]
✅주기억 장치 공간 절약
✅참조되는 정보와 무관한 양의 정보가 주기억 장치에 남게 됨
✅테이블이 복잡하지 않아 관리 용이

75. 다음 중 가장 강한 응집도(Cohesion)는? 1

1Sequential Cohesion

2️Procedural Cohesion

3️Logical Cohesion

4️Coincidental Cohesion

[ 응집도 : 모듈내부의 기능적인 응집 정도 ]
[ 응집도의 순서 : 1(작음) ➡ 7(큼) ]
1. 우연적(Coincidental)응집도
2. 논리적(Logical) 응집도
3. 시간적 응집도(Temporal)
4. 절차적(Procedural) 응집도
5. 교환적(Communication) 응집도
6. 순차적(Sequential) 응집도
7. 기능적(Functional) 응집도


76. TCP 프로토콜과 관련한 설명으로 틀린 것은? 1

1️인접한 노드 사이의 프레임 전송 및 오류를 제어한다

2️흐름 제어(Flow Control)의 기능을 수행한다

3️전이 중(Full Duplex) 방식의 양방향 가상회선을 제공한다

4️전송 데이터와 응답 데이터를 함께 전송할 수 있다

1번은 데이터 링크 계층에 해당하는 설명이다.

77. C언어에서 연산자 우선순위가 높은 것에서 낮은 것으로 바르게 나열된 것은? 1


보기
1️㉠, ㉥, ㉣, ㉢, ㉡, ㉤

2️㉠, ㉣, ㉥, ㉢, ㉡, ㉤

3️㉠, ㉣, ㉥, ㉢, ㉤, ㉡

4️㉠, ㉥, ㉣, ㉤, ㉡, ㉢

[ 연산자의 우선 순위 ]
우선순위 높음 → 우선순위 낮음
증감 연산자( ++ -- ) → 산술 연산자( * / % ) → 산술 연산자( +   - ) → 시프트 연산자( << >> ) → 관계 연산자(=< => < > ) → 관계 연산자( == != ) → 비트 연산자( & ^ | ) → 논리 연산자( && ||) → 조건연산자(?:) → 대입연산자(= += *= /= %= <<= >>=) → 순서 연산자( , )

80. OSI 7계층 중 네트워크 계층에 대한 설명으로 틀린 것은? 2

1️패킷을 발신지로부터 최종 목적지까지 전달하는 책임을 진다

2️한 노드로부터 다른 노드로 프레임을 전송하는 책임을 진다

3️패킷에 발신지와 목적지의 논리 주소를 추가한다

4️라우터 또는 교환기는 패킷 전달을 위해 경로를 지정하거나 교환 기능을 제공한다

한 노드에서 다른 노드로 프레임을 전송하는 책임을 갖는 층(Layer)은 데이터 링크 계층